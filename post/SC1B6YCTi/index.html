<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>青屋</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="我有一壶酒，足以慰风尘"/>
<meta name="keywords" content="我有一壶酒，足以慰风尘"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://qingwu-aby.github.io/favicon.ico">

<link rel="stylesheet" href="https://qingwu-aby.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://qingwu-aby.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://qingwu-aby.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://qingwu-aby.github.io/images/avatar.png" alt="青屋"
                 class="img-responsive">
        </figure>
        <a href="https://qingwu-aby.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>青屋</h2>
        <p>我有一壶酒，足以慰风尘</p>
        <ul class="fh5co-social">
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://qingwu-aby.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://qingwu-aby.github.io/tag/Bo2MqkwLq/">React</a></li>
                
                    <li><a href="https://qingwu-aby.github.io/tag/WHkzkmUVJ/">JS基础</a></li>
                
                    <li><a href="https://qingwu-aby.github.io/tag/HDG5upSe4/">算法和数据结构</a></li>
                
                    <li><a href="https://qingwu-aby.github.io/tag/o-FN4Uam8n/">todo</a></li>
                
                    <li><a href="https://qingwu-aby.github.io/tag/H8FJNbNzO/">一些问题</a></li>
                
                    <li><a href="https://qingwu-aby.github.io/tag/iheqDLI6k/">埋点</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            分类
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://qingwu-aby.github.io">青屋 </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
            </span>
            <h2 class="fh5co-article-title animate-box">React源码系列4---commit阶段</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-10-06</li>
                <li>2033字</li>
                <li>10 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <blockquote>
<p><code>render阶段</code>中最后调用的<code>commitRoot</code>是<code>commit阶段</code>的工作起点。<code>fiberRootNode</code>作为传参<code>commitRoot(root)</code></p>
</blockquote>
<!-- more -->
<h1 id="commit">commit</h1>
<ul>
<li><s>在<code>rootFiber.firstEffct</code>上保存了一条需要执行<code>副作用</code>的<code>Fiber节点</code>的单向链表<code>effectList</code></s>,最近的一次更新中<strong>react官方</strong>使用了<code>subtreeHasEffects</code>和<code>rootHasEffect</code>获取<code>副作用</code>的<code>Fiber节点</code><br>
，这些<code>Fiber节点</code>的<code>updateQueue</code>中保存了变化的<code>props</code></li>
<li>这些<code>副作用</code>对应的<code>DOM操作</code>会在<code>commit阶段</code>执行</li>
<li>部分生命周期钩子函数<code>componentDid***</code>，<code>hook</code>（<code>useEffect</code>）需要在<code>commit阶段</code>执行</li>
</ul>
<p><code>commit阶段</code>的主要工作（即<code>Renderer</code>的工作流程）：</p>
<ol>
<li><code>before mutation</code>阶段（执行<code>DOM操作</code>之前）</li>
<li><code>mutation</code>阶段（执行<code>DOM</code>操作）</li>
<li><code>layout</code>阶段（执行<code>DOM</code>操作之后）</li>
</ol>
<blockquote>
<p><code>commitRootImpl</code>--&gt;<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1784">commitRootImpl</a><br>
在<code>before mutation阶段</code>组件之前以及<code>layout阶段之后</code>还涉及到<code>useEffect</code>的触发，<code>优先级</code>重置，<code>ref</code>的绑定/解绑等</p>
</blockquote>
<h2 id="commit流程">commit流程</h2>
<h3 id="before-mutation-之前">before mutation 之前</h3>
<p><code>commitRootImpl</code>方法中一直到<code>if (subtreeHasEffects || rootHasEffect)</code>之前，属于<code>before mutation之前</code></p>
<pre><code class="language-javascript">do {
    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
    // means `flushPassiveEffects` will sometimes result in additional
    // passive effects. So we need to keep flushing in a loop until there are
    // no more pending effects.
    // TODO: Might be better if `flushPassiveEffects` did not automatically
    // flush synchronous work at the end, to avoid factoring hazards like this.
    // 触发useEffect回调与其他的同步任务，由于可能会引发新的渲染。所以这里需要遍历到最终没有任务为止
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);
    // root : fiberRootNode
    // root.finishedLanes 指当前应用的rootFiber
  const finishedWork = root.finishedWork;
    // lanes 与优先级相关的变量
  const lanes = root.finishedLanes;

  if (enableSchedulingProfiler) {
    markCommitStarted(lanes);
  }

  if (finishedWork === null) {

    if (enableSchedulingProfiler) {
      markCommitStopped();
    }

    return null;
  }

  // 重置Scheduler绑定的回调
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  // commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.
  root.callbackNode = null;

  // Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.
  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  // 重置优先级变量
  markRootFinished(root, remainingLanes);

  // Clear already finished discrete updates in case that a later call of
  // `flushDiscreteUpdates` starts a useless render pass which may cancels
  // a scheduled timeout.
  // 清理已经完成的discrete updates，eg: 鼠标点击触发的更新
  if (rootsWithPendingDiscreteUpdates !== null) {
    if (
      !hasDiscreteLanes(remainingLanes) &amp;&amp;
      rootsWithPendingDiscreteUpdates.has(root)
    ) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }
    // 重置全局变量
  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } else {
    // This indicates that the last root we worked on is not the same one that
    // we're committing now. This most commonly happens when a suspended root
    // times out.
  }
  // Check if there are any effects in the whole tree.
  // TODO: This is left over from the effect list implementation, where we had
  // to check for the existence of `firstEffect` to satsify Flow. I think the
  // only other reason this optimization exists is because it affects profiling.
  // Reconsider whether this is necessary.
  // 判断当前的树上面是否还有副作用的节点
  const subtreeHasEffects =
    (finishedWork.subtreeFlags &amp;
      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
    NoFlags;
  const rootHasEffect =
    (finishedWork.flags &amp;
      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
    NoFlags;
    if (subtreeHasEffects || rootHasEffect) {

    } else {
        // No effects.
        root.current = finishedWork;
        // Measure these anyway so the flamegraph explicitly shows that there were
        // no effects.
        // TODO: Maybe there's a better way to report this.
        if (enableProfilerTimer) {
            recordCommitTime();
        }
    }
</code></pre>
<blockquote>
<p><code>before mutation之前</code>的阶段都是在处理变量的赋值，以及状态的重置等操作</p>
</blockquote>
<h3 id="layout-之后">layout 之后</h3>
<pre><code class="language-javascript">const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}

// 性能优化相关
if (remainingLanes !== NoLanes) {
  if (enableSchedulerTracing) {
    // ...
  }
} else {
  // ...
}

// 性能优化相关
if (enableSchedulerTracing) {
  if (!rootDidHavePassiveEffects) {
    // ...
  }
}

// ...检测无限循环的同步任务
if (remainingLanes === SyncLane) {
  // ...
} 

// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度
ensureRootIsScheduled(root, now());

// ...处理未捕获错误及老版本遗留的边界问题
// 执行同步任务，这样同步任务不需要等到下次事件循环再执行
// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行
// 或useLayoutEffect
flushSyncCallbackQueue();
return null;
</code></pre>
<p>主要包含三个方面：</p>
<ol>
<li><code>useEffect</code>的相关处理</li>
<li>性能追踪</li>
<li>在<code>commit</code>阶段会触发一些生命周期钩子(<code>componentDid***</code>)和<code>hook</code>（<code>useLayoutEffect</code>, <code>useEffect</code>）</li>
</ol>
<blockquote>
<p>在这些回调方法中可能会触发新的更新，新的更新会开启新的<code>render-commit</code>过程，例如：</p>
<ol>
<li>触发点击事件，页面中令一个状态变为<code>0</code></li>
<li>在<code>useLayoutEffect</code>中设置为随机数</li>
<li>页面上渲染的数字不是<code>0</code>，而是变成随机数</li>
</ol>
</blockquote>
<p>因为<code>useEffectLayout</code>在<code>layout阶段</code>同步执行回调，回调中触发状态更新，这个操作会重新调度一个新的任务:---&gt;<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2114">flushSyncCallbackQueue</a></p>
<pre><code class="language-javascript">// If layout work was scheduled, flush it now.
  flushSyncCallbackQueue();
</code></pre>
<p>所以看不到页面中的数字先变成<code>0</code></p>
<h2 id="before-mutation">before mutation</h2>
<p><code>Renderer</code>工作的阶段被称为<code>commit阶段</code>，<code>commit阶段</code>分为三个部分</p>
<ul>
<li>
<p>before mutation（执行<code>DOM操作前</code>）</p>
</li>
<li>
<p>mutation阶段（执行<code>DOM</code>操作）</p>
</li>
<li>
<p>layout阶段（执行<code>DOM</code>操作之后）</p>
<blockquote>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1882-L1909">before mutation阶段</a></p>
</blockquote>
<pre><code class="language-javascript">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级
</code></pre>
</li>
</ul>
<p>const previousLanePriority = getCurrentUpdateLanePriority();<br>
setCurrentUpdateLanePriority(SyncLanePriority);</p>
<p>// 将当前上下文标记为CommitContext，作为commit阶段的标志<br>
const prevExecutionContext = executionContext;<br>
executionContext |= CommitContext;</p>
<p>// 处理focus状态<br>
focusedInstanceHandle = prepareForCommit(root.containerInfo);<br>
shouldFireAfterActiveInstanceBlur = false;</p>
<p>// beforeMutation阶段的主函数<br>
commitBeforeMutationEffects(finishedWork);</p>
<p>focusedInstanceHandle = null;</p>
<pre><code>这里需要关注主函数`commitBeforeMutationEffects`的作用

### commitBeforeMutationEffects

`commitBeforeMutationEffects` 直接去调度`commitBeforeMutationEffectsImpl`
代码逻辑：
``` javascript
function commitBeforeMutationEffects(firstChild: Fiber) {
let fiber = firstChild;
while (fiber !== null) {
  if (fiber.deletions !== null) {
    commitBeforeMutationEffectsDeletions(fiber.deletions);
  }
  if (fiber.child !== null) {
    const primarySubtreeFlags = fiber.subtreeFlags &amp; BeforeMutationMask;
    if (primarySubtreeFlags !== NoFlags) {
      commitBeforeMutationEffects(fiber.child);
    }
  }

 try {
      commitBeforeMutationEffectsImpl(fiber);
    } catch (error) {
      captureCommitPhaseError(fiber, fiber.return, error);
    }
  fiber = fiber.sibling;
}
}
</code></pre>
<p>commitBeforeMutationEffectsImpl:</p>
<pre><code class="language-javascript">function commitBeforeMutationEffectsImpl(fiber: Fiber) {
  const current = fiber.alternate;
  const flags = fiber.flags;
// focus相关
  if (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== null) {
    // Check to see if the focused element was inside of a hidden (Suspense) subtree.
    // TODO: Move this out of the hot path using a dedicated effect tag.
    if (
      fiber.tag === SuspenseComponent &amp;&amp;
      isSuspenseBoundaryBeingHidden(current, fiber) &amp;&amp;
      doesFiberContain(fiber, focusedInstanceHandle)
    ) {
      shouldFireAfterActiveInstanceBlur = true;
      beforeActiveInstanceBlur();
    }
  }
  // 调用getSnapshotBeforeUpdate

  if ((flags &amp; Snapshot) !== NoFlags) {
    setCurrentDebugFiberInDEV(fiber);
    commitBeforeMutationEffectOnFiber(current, fiber);
    resetCurrentDebugFiberInDEV();
  }
 // 调度useEffect
  if ((flags &amp; Passive) !== NoFlags) {
    // If there are passive effects, schedule a callback to flush at
    // the earliest opportunity.
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(NormalSchedulerPriority, () =&gt; {
        flushPassiveEffects();
        return null;
      });
    }
  }
}
</code></pre>
<p>整体分为三个部分：</p>
<ol>
<li>处理<code>DOM节点</code>渲染/删除后的<code>autoFocus</code>，<code>blur</code>逻辑</li>
<li>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</li>
<li>调度<code>useEffect</code></li>
</ol>
<h3 id="调用getsnapshotbeforeupdate">调用getSnapshotBeforeUpdate</h3>
<blockquote>
<p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名,<br>
这个方法内部会调用<code>getSnapshotBeforeUpdate</code>:<br>
<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L237">commitBeforeMutationLifeCycles方法</a></p>
</blockquote>
<pre><code class="language-javascript">const snapshot = instance.getSnapshotBeforeUpdate(
    finishedWork.elementType === finishedWork.type
        ? prevProps
        : resolveDefaultProps(finishedWork.type, prevProps),
    prevState,
);
</code></pre>
<p><code>getSnapshotBeforeUpdate</code>在<code>commit阶段</code>内的<code>before mutation</code>阶段调用的，由于<code>commit</code>是同步进行的，所以不会出现多次调用的问题</p>
<h3 id="调度useeffect">调度useEffect</h3>
<p><code>scheduleCallback</code>方法就是由<code>Scheduler</code>模块提供，用于某个优先级异步调度一个回调函数</p>
<pre><code class="language-javascript">// 调度useEffect
if ((flags &amp; Passive) !== NoFlags) {
    // If there are passive effects, schedule a callback to flush at
    // the earliest opportunity.
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(NormalSchedulerPriority, () =&gt; {
        flushPassiveEffects();
        return null;
      });
    }
  }
</code></pre>
<p>此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code></p>
<h4 id="如何异步调度">如何异步调度</h4>
<pre><code class="language-javascript">export function flushPassiveEffects(): boolean {
  // Returns whether passive effects were flushed.
  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {
    const priorityLevel =
      pendingPassiveEffectsRenderPriority &gt; NormalSchedulerPriority
        ? NormalSchedulerPriority
        : pendingPassiveEffectsRenderPriority;
    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;
    if (decoupleUpdatePriorityFromScheduler) {
      const previousLanePriority = getCurrentUpdateLanePriority();
      try {
        setCurrentUpdateLanePriority(
          schedulerPriorityToLanePriority(priorityLevel),
        );
        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
      } finally {
        setCurrentUpdateLanePriority(previousLanePriority);
      }
    } else {
      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
    }
  }
  return false;
}
</code></pre>
<p>通过之前的了解<code>render阶段</code>：<code>Fiber节点</code>更新过程中的副作用包括</p>
<ol>
<li>插入<code>DOM节点</code>（Placement）</li>
<li>删除<code>DOM节点</code>（Deletion）</li>
<li>更新<code>DOM节点</code>（Update）<br>
除此之外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或者<code>useLayoutEffect</code>的时候，他对应的<code>Fiber节点</code>也会被赋值<code>flags</code></li>
</ol>
<p>在<code>commitRootImpl</code>方法中会循环遍历<code>rootWithPendingPassiveEffects</code>执行有副作用的回调函数</p>
<p>整个<code>useEffect</code>的异步调用分为三个部分：</p>
<ol>
<li><code>before mutation</code>阶段在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li>
<li><code>layout</code>阶段之后将effectList赋值给<code>rootWithPendingPassiveEffects</code></li>
<li><code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code></li>
</ol>
<blockquote>
<p><code>useEffect</code>: 在浏览器完成布局与绘制之后，传递给useEffect的函数会延迟调用</p>
</blockquote>
<p>使用<code>useEffect</code>异步执行的原因主要是为了纺织同步执行时阻塞浏览器的渲染</p>
<h3 id="总结">总结</h3>
<p><code>before mutation</code>阶段会通过<code>commitBeforeMutationEffects</code>去遍历有<code>effect</code>的<code>Fiber节点</code>：</p>
<ol>
<li>处理DOM节点<strong>渲染/删除</strong>后的<code>Focus</code>/<code>onblur</code>逻辑</li>
<li>调用<code>getSnapshotBeforeUpdate</code>生命周期</li>
<li>调度<code>useEffect</code></li>
</ol>
<h2 id="mutation阶段">mutation阶段</h2>
<p>与<code>before mutation阶段</code>相似的是<code>mutation阶段</code>也会去遍历<code>effect</code>的<code>Fiber节点</code>，不同的是：<code>mutation阶段</code>调用的是<code>commitBeforeMutationEffects</code>方法</p>
<pre><code class="language-javascript"> // The next phase is the mutation phase, where we mutate the host tree.
    commitMutationEffects(finishedWork, root, renderPriorityLevel);

    if (shouldFireAfterActiveInstanceBlur) {
      afterActiveInstanceBlur();
    }
    resetAfterCommit(root.containerInfo);

    // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.
    root.current = finishedWork;
</code></pre>
<h4 id="总结-2">总结</h4>
<p><code>mutation阶段</code>会遍历有<code>effect</code>的<code>Fiber节点</code>，主要方法在<code>commitMutationEffects</code>，根据<code>flags</code>状态的不同调用不同的处理方法去处理<code>Fiber</code></p>
<h2 id="layout阶段">layout阶段</h2>
<ul>
<li>在当前阶段代码都在<code>DOM</code>渲染完成(<code>mutation阶段</code>)之后执行的</li>
<li>当前阶段触发的生命周期钩子和<code>hook</code>可以直接访问到已经改变之后的<code>DOM</code>，当前阶段可以直接参与<code>DOM layout</code>的阶段</li>
</ul>
<h3 id=""></h3>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://qingwu-aby.github.io/post/85DIMWyxi/">
                                    <h3 class="post-title">
                                        React源码系列3---Render阶段
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li><a href="#commit">commit</a>
<ul>
<li><a href="#commit%E6%B5%81%E7%A8%8B">commit流程</a>
<ul>
<li><a href="#before-mutation-%E4%B9%8B%E5%89%8D">before mutation 之前</a></li>
<li><a href="#layout-%E4%B9%8B%E5%90%8E">layout 之后</a></li>
</ul>
</li>
<li><a href="#before-mutation">before mutation</a>
<ul>
<li><a href="#%E8%B0%83%E7%94%A8getsnapshotbeforeupdate">调用getSnapshotBeforeUpdate</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6useeffect">调度useEffect</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6">如何异步调度</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#mutation%E9%98%B6%E6%AE%B5">mutation阶段</a><br>
*
<ul>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#layout%E9%98%B6%E6%AE%B5">layout阶段</a><br>
*</li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p></p>
</footer>


    <!-- jQuery -->
<script src="https://qingwu-aby.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://qingwu-aby.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://qingwu-aby.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://qingwu-aby.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://qingwu-aby.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://qingwu-aby.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://qingwu-aby.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
</script>




</body>
</html>
